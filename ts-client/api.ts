/* tslint:disable */
/* eslint-disable */
/**
 * mogazoa-api
 * Mogazoa project API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 *
 * @export
 * @interface Category
 */
export interface Category {
  /**
   *
   * @type {string}
   * @memberof Category
   */
  updatedAt: string;
  /**
   *
   * @type {string}
   * @memberof Category
   */
  createdAt: string;
  /**
   *
   * @type {string}
   * @memberof Category
   */
  name: string;
  /**
   *
   * @type {number}
   * @memberof Category
   */
  id: number;
}
/**
 *
 * @export
 * @interface CreateProductRequestBody
 */
export interface CreateProductRequestBody {
  /**
   *
   * @type {number}
   * @memberof CreateProductRequestBody
   */
  categoryId: number;
  /**
   *
   * @type {string}
   * @memberof CreateProductRequestBody
   */
  image: string;
  /**
   * 상품 설명
   * @type {string}
   * @memberof CreateProductRequestBody
   */
  description: string;
  /**
   * 상품 이름
   * @type {string}
   * @memberof CreateProductRequestBody
   */
  name: string;
}
/**
 *
 * @export
 * @interface CreateReviewRequestBody
 */
export interface CreateReviewRequestBody {
  /**
   *
   * @type {number}
   * @memberof CreateReviewRequestBody
   */
  productId: number;
  /**
   * 이미지 URL 입니다. 최대 3개까지 가능합니다.
   * @type {Array<string>}
   * @memberof CreateReviewRequestBody
   */
  images?: Array<string>;
  /**
   *
   * @type {string}
   * @memberof CreateReviewRequestBody
   */
  content: string;
  /**
   *
   * @type {number}
   * @memberof CreateReviewRequestBody
   */
  rating: number;
}
/**
 *
 * @export
 * @interface CursorBasedPaginationResponseIdNumberFolloweeUser
 */
export interface CursorBasedPaginationResponseIdNumberFolloweeUser {
  /**
   *
   * @type {number}
   * @memberof CursorBasedPaginationResponseIdNumberFolloweeUser
   */
  nextCursor: number | null;
  /**
   *
   * @type {Array<CursorBasedPaginationResponseIdNumberFolloweeUserListInner>}
   * @memberof CursorBasedPaginationResponseIdNumberFolloweeUser
   */
  list: Array<CursorBasedPaginationResponseIdNumberFolloweeUserListInner>;
}
/**
 *
 * @export
 * @interface CursorBasedPaginationResponseIdNumberFolloweeUserListInner
 */
export interface CursorBasedPaginationResponseIdNumberFolloweeUserListInner {
  /**
   *
   * @type {User}
   * @memberof CursorBasedPaginationResponseIdNumberFolloweeUserListInner
   */
  followee: User;
  /**
   *
   * @type {number}
   * @memberof CursorBasedPaginationResponseIdNumberFolloweeUserListInner
   */
  id: number;
}
/**
 *
 * @export
 * @interface CursorBasedPaginationResponseIdNumberFollowerUser
 */
export interface CursorBasedPaginationResponseIdNumberFollowerUser {
  /**
   *
   * @type {number}
   * @memberof CursorBasedPaginationResponseIdNumberFollowerUser
   */
  nextCursor: number | null;
  /**
   *
   * @type {Array<CursorBasedPaginationResponseIdNumberFollowerUserListInner>}
   * @memberof CursorBasedPaginationResponseIdNumberFollowerUser
   */
  list: Array<CursorBasedPaginationResponseIdNumberFollowerUserListInner>;
}
/**
 *
 * @export
 * @interface CursorBasedPaginationResponseIdNumberFollowerUserListInner
 */
export interface CursorBasedPaginationResponseIdNumberFollowerUserListInner {
  /**
   *
   * @type {User}
   * @memberof CursorBasedPaginationResponseIdNumberFollowerUserListInner
   */
  follower: User;
  /**
   *
   * @type {number}
   * @memberof CursorBasedPaginationResponseIdNumberFollowerUserListInner
   */
  id: number;
}
/**
 *
 * @export
 * @interface CursorBasedPaginationResponseProductListType
 */
export interface CursorBasedPaginationResponseProductListType {
  /**
   *
   * @type {number}
   * @memberof CursorBasedPaginationResponseProductListType
   */
  nextCursor: number | null;
  /**
   *
   * @type {Array<ProductListType>}
   * @memberof CursorBasedPaginationResponseProductListType
   */
  list: Array<ProductListType>;
}
/**
 *
 * @export
 * @interface CursorBasedPaginationResponseReview
 */
export interface CursorBasedPaginationResponseReview {
  /**
   *
   * @type {number}
   * @memberof CursorBasedPaginationResponseReview
   */
  nextCursor: number | null;
  /**
   *
   * @type {Array<Review>}
   * @memberof CursorBasedPaginationResponseReview
   */
  list: Array<Review>;
}
/**
 *
 * @export
 * @interface DeleteProduct200Response
 */
export interface DeleteProduct200Response {
  /**
   *
   * @type {number}
   * @memberof DeleteProduct200Response
   */
  id: number;
}
/**
 *
 * @export
 * @interface DeleteReview200Response
 */
export interface DeleteReview200Response {
  /**
   *
   * @type {number}
   * @memberof DeleteReview200Response
   */
  productId: number;
  /**
   *
   * @type {number}
   * @memberof DeleteReview200Response
   */
  userId: number;
  /**
   *
   * @type {string}
   * @memberof DeleteReview200Response
   */
  updatedAt: string;
  /**
   *
   * @type {string}
   * @memberof DeleteReview200Response
   */
  createdAt: string;
  /**
   *
   * @type {number}
   * @memberof DeleteReview200Response
   */
  likeCount: number;
  /**
   *
   * @type {number}
   * @memberof DeleteReview200Response
   */
  rating: number;
  /**
   *
   * @type {string}
   * @memberof DeleteReview200Response
   */
  content: string;
  /**
   *
   * @type {number}
   * @memberof DeleteReview200Response
   */
  id: number;
}
/**
 *
 * @export
 * @interface FollowRequestBody
 */
export interface FollowRequestBody {
  /**
   *
   * @type {number}
   * @memberof FollowRequestBody
   */
  userId: number;
}
/**
 *
 * @export
 * @interface ImageUpload200Response
 */
export interface ImageUpload200Response {
  /**
   *
   * @type {string}
   * @memberof ImageUpload200Response
   */
  url: string;
}
/**
 *
 * @export
 * @interface OauthApp
 */
export interface OauthApp {
  /**
   *
   * @type {string}
   * @memberof OauthApp
   */
  createdAt: string;
  /**
   *
   * @type {string}
   * @memberof OauthApp
   */
  updatedAt: string;
  /**
   *
   * @type {string}
   * @memberof OauthApp
   */
  appKey: string;
  /**
   *
   * @type {string}
   * @memberof OauthApp
   */
  provider: string;
  /**
   *
   * @type {string}
   * @memberof OauthApp
   */
  teamId: string;
  /**
   *
   * @type {number}
   * @memberof OauthApp
   */
  id: number;
}
/**
 *
 * @export
 * @enum {string}
 */

export const OauthProvider = {
  Google: 'google',
  Kakao: 'kakao',
} as const;

export type OauthProvider = (typeof OauthProvider)[keyof typeof OauthProvider];

/**
 *
 * @export
 * @interface ProductDetailType
 */
export interface ProductDetailType {
  /**
   *
   * @type {string}
   * @memberof ProductDetailType
   */
  updatedAt: string;
  /**
   *
   * @type {string}
   * @memberof ProductDetailType
   */
  createdAt: string;
  /**
   *
   * @type {number}
   * @memberof ProductDetailType
   */
  writerId: number;
  /**
   *
   * @type {number}
   * @memberof ProductDetailType
   */
  categoryId: number;
  /**
   *
   * @type {number}
   * @memberof ProductDetailType
   */
  favoriteCount: number;
  /**
   *
   * @type {number}
   * @memberof ProductDetailType
   */
  reviewCount: number;
  /**
   *
   * @type {number}
   * @memberof ProductDetailType
   */
  rating: number;
  /**
   *
   * @type {string}
   * @memberof ProductDetailType
   */
  image: string;
  /**
   *
   * @type {string}
   * @memberof ProductDetailType
   */
  name: string;
  /**
   *
   * @type {number}
   * @memberof ProductDetailType
   */
  id: number;
  /**
   *
   * @type {ProductDetailTypeAllOfCategoryMetric}
   * @memberof ProductDetailType
   */
  categoryMetric: ProductDetailTypeAllOfCategoryMetric;
  /**
   *
   * @type {ProductDetailTypeAllOfCategory}
   * @memberof ProductDetailType
   */
  category: ProductDetailTypeAllOfCategory;
  /**
   *
   * @type {boolean}
   * @memberof ProductDetailType
   */
  isFavorite: boolean;
  /**
   *
   * @type {string}
   * @memberof ProductDetailType
   */
  description: string;
}
/**
 *
 * @export
 * @interface ProductDetailTypeAllOfCategory
 */
export interface ProductDetailTypeAllOfCategory {
  /**
   *
   * @type {string}
   * @memberof ProductDetailTypeAllOfCategory
   */
  name: string;
  /**
   *
   * @type {number}
   * @memberof ProductDetailTypeAllOfCategory
   */
  id: number;
}
/**
 * 동일 카테고리 지표
 * @export
 * @interface ProductDetailTypeAllOfCategoryMetric
 */
export interface ProductDetailTypeAllOfCategoryMetric {
  /**
   *
   * @type {number}
   * @memberof ProductDetailTypeAllOfCategoryMetric
   */
  reviewCount: number;
  /**
   *
   * @type {number}
   * @memberof ProductDetailTypeAllOfCategoryMetric
   */
  favoriteCount: number;
  /**
   *
   * @type {number}
   * @memberof ProductDetailTypeAllOfCategoryMetric
   */
  rating: number;
}
/**
 *
 * @export
 * @interface ProductListType
 */
export interface ProductListType {
  /**
   *
   * @type {string}
   * @memberof ProductListType
   */
  updatedAt: string;
  /**
   *
   * @type {string}
   * @memberof ProductListType
   */
  createdAt: string;
  /**
   *
   * @type {number}
   * @memberof ProductListType
   */
  writerId: number;
  /**
   *
   * @type {number}
   * @memberof ProductListType
   */
  categoryId: number;
  /**
   *
   * @type {number}
   * @memberof ProductListType
   */
  favoriteCount: number;
  /**
   *
   * @type {number}
   * @memberof ProductListType
   */
  reviewCount: number;
  /**
   *
   * @type {number}
   * @memberof ProductListType
   */
  rating: number;
  /**
   *
   * @type {string}
   * @memberof ProductListType
   */
  image: string;
  /**
   *
   * @type {string}
   * @memberof ProductListType
   */
  name: string;
  /**
   *
   * @type {number}
   * @memberof ProductListType
   */
  id: number;
}
/**
 *
 * @export
 * @interface RetrieveProduct404Response
 */
export interface RetrieveProduct404Response {
  /**
   *
   * @type {string}
   * @memberof RetrieveProduct404Response
   */
  message: string;
}
/**
 *
 * @export
 * @interface Review
 */
export interface Review {
  /**
   *
   * @type {ReviewUser}
   * @memberof Review
   */
  user: ReviewUser;
  /**
   *
   * @type {Array<ReviewReviewImagesInner>}
   * @memberof Review
   */
  reviewImages: Array<ReviewReviewImagesInner>;
  /**
   *
   * @type {number}
   * @memberof Review
   */
  productId: number;
  /**
   *
   * @type {number}
   * @memberof Review
   */
  userId: number;
  /**
   *
   * @type {string}
   * @memberof Review
   */
  updatedAt: string;
  /**
   *
   * @type {string}
   * @memberof Review
   */
  createdAt: string;
  /**
   *
   * @type {boolean}
   * @memberof Review
   */
  isLiked: boolean;
  /**
   *
   * @type {number}
   * @memberof Review
   */
  likeCount: number;
  /**
   *
   * @type {string}
   * @memberof Review
   */
  content: string;
  /**
   *
   * @type {number}
   * @memberof Review
   */
  rating: number;
  /**
   *
   * @type {number}
   * @memberof Review
   */
  id: number;
}
/**
 *
 * @export
 * @interface ReviewReviewImagesInner
 */
export interface ReviewReviewImagesInner {
  /**
   *
   * @type {string}
   * @memberof ReviewReviewImagesInner
   */
  source: string;
  /**
   *
   * @type {number}
   * @memberof ReviewReviewImagesInner
   */
  id: number;
}
/**
 *
 * @export
 * @interface ReviewUser
 */
export interface ReviewUser {
  /**
   *
   * @type {string}
   * @memberof ReviewUser
   */
  image: string | null;
  /**
   *
   * @type {string}
   * @memberof ReviewUser
   */
  nickname: string;
  /**
   *
   * @type {number}
   * @memberof ReviewUser
   */
  id: number;
}
/**
 *
 * @export
 * @interface SignInRequestBody
 */
export interface SignInRequestBody {
  /**
   *
   * @type {string}
   * @memberof SignInRequestBody
   */
  password: string;
  /**
   *
   * @type {string}
   * @memberof SignInRequestBody
   */
  email: string;
}
/**
 *
 * @export
 * @interface SignInResponse
 */
export interface SignInResponse {
  /**
   *
   * @type {string}
   * @memberof SignInResponse
   */
  accessToken: string;
  /**
   *
   * @type {SignUpResponseUser}
   * @memberof SignInResponse
   */
  user: SignUpResponseUser;
}
/**
 *
 * @export
 * @interface SignInWithOauthRequestBody
 */
export interface SignInWithOauthRequestBody {
  /**
   * Kakao 의 경우에는 필수입니다.<br/> 인가 코드를 얻을 때 사용하였던 redirect_uri 값을 그대로 사용합니다.
   * @type {string}
   * @memberof SignInWithOauthRequestBody
   */
  redirectUri?: string;
  /**
   * 간편 로그인 과정을 통해 발급받은 토큰입니다.<br /> Google 의 경우에는 <b>Google Id 토큰</b>(JWT) 입니다.<br/> Kakao 의 경우에는 <b>인가 코드</b> 입니다.
   * @type {string}
   * @memberof SignInWithOauthRequestBody
   */
  token: string;
}
/**
 *
 * @export
 * @interface SignUpRequestBody
 */
export interface SignUpRequestBody {
  /**
   *
   * @type {string}
   * @memberof SignUpRequestBody
   */
  passwordConfirmation: string;
  /**
   *
   * @type {string}
   * @memberof SignUpRequestBody
   */
  password: string;
  /**
   *
   * @type {string}
   * @memberof SignUpRequestBody
   */
  nickname: string;
  /**
   *
   * @type {string}
   * @memberof SignUpRequestBody
   */
  email: string;
}
/**
 *
 * @export
 * @interface SignUpResponse
 */
export interface SignUpResponse {
  /**
   *
   * @type {string}
   * @memberof SignUpResponse
   */
  accessToken: string;
  /**
   *
   * @type {SignUpResponseUser}
   * @memberof SignUpResponse
   */
  user: SignUpResponseUser;
}
/**
 *
 * @export
 * @interface SignUpResponseUser
 */
export interface SignUpResponseUser {
  /**
   *
   * @type {string}
   * @memberof SignUpResponseUser
   */
  updatedAt: string;
  /**
   *
   * @type {string}
   * @memberof SignUpResponseUser
   */
  createdAt: string;
  /**
   *
   * @type {string}
   * @memberof SignUpResponseUser
   */
  teamId: string;
  /**
   *
   * @type {string}
   * @memberof SignUpResponseUser
   */
  image: string | null;
  /**
   *
   * @type {string}
   * @memberof SignUpResponseUser
   */
  description: string;
  /**
   *
   * @type {string}
   * @memberof SignUpResponseUser
   */
  nickname: string;
  /**
   *
   * @type {number}
   * @memberof SignUpResponseUser
   */
  id: number;
  /**
   *
   * @type {string}
   * @memberof SignUpResponseUser
   */
  email: string;
}
/**
 *
 * @export
 * @interface SignUpWithOauthRequestBody
 */
export interface SignUpWithOauthRequestBody {
  /**
   * Kakao 의 경우에는 필수입니다.<br/> 인가 코드를 얻을 때 사용하였던 redirect_uri 값을 그대로 사용합니다.
   * @type {string}
   * @memberof SignUpWithOauthRequestBody
   */
  redirectUri?: string;
  /**
   * 간편 로그인 과정을 통해 발급받은 토큰입니다.<br /> Google 의 경우에는 <b>Google Id 토큰</b>(JWT) 입니다.<br/> Kakao 의 경우에는 <b>인가 코드</b> 입니다.
   * @type {string}
   * @memberof SignUpWithOauthRequestBody
   */
  token: string;
  /**
   *
   * @type {string}
   * @memberof SignUpWithOauthRequestBody
   */
  nickname: string;
}
/**
 *
 * @export
 * @interface UpdateMe200Response
 */
export interface UpdateMe200Response {
  /**
   *
   * @type {string}
   * @memberof UpdateMe200Response
   */
  updatedAt: string;
  /**
   *
   * @type {string}
   * @memberof UpdateMe200Response
   */
  createdAt: string;
  /**
   *
   * @type {string}
   * @memberof UpdateMe200Response
   */
  teamId: string;
  /**
   *
   * @type {string}
   * @memberof UpdateMe200Response
   */
  image: string | null;
  /**
   *
   * @type {string}
   * @memberof UpdateMe200Response
   */
  description: string;
  /**
   *
   * @type {string}
   * @memberof UpdateMe200Response
   */
  nickname: string;
  /**
   *
   * @type {number}
   * @memberof UpdateMe200Response
   */
  id: number;
}
/**
 *
 * @export
 * @interface UpdateProductRequestBody
 */
export interface UpdateProductRequestBody {
  /**
   *
   * @type {number}
   * @memberof UpdateProductRequestBody
   */
  categoryId: number;
  /**
   *
   * @type {string}
   * @memberof UpdateProductRequestBody
   */
  image: string;
  /**
   * 상품 설명
   * @type {string}
   * @memberof UpdateProductRequestBody
   */
  description: string;
  /**
   * 상품 이름
   * @type {string}
   * @memberof UpdateProductRequestBody
   */
  name: string;
}
/**
 *
 * @export
 * @interface UpdateReviewRequestBody
 */
export interface UpdateReviewRequestBody {
  /**
   * 기존 이미지를 유지하려면 id를, 새로운 이미지를 추가하려면 source를 넣어주세요. <br /> 요청에 포함되지 않는 기존 이미지는 삭제됩니다.
   * @type {Array<UpdateReviewRequestBodyImagesInner>}
   * @memberof UpdateReviewRequestBody
   */
  images?: Array<UpdateReviewRequestBodyImagesInner>;
  /**
   *
   * @type {string}
   * @memberof UpdateReviewRequestBody
   */
  content?: string;
  /**
   *
   * @type {number}
   * @memberof UpdateReviewRequestBody
   */
  rating?: number;
}
/**
 *
 * @export
 * @interface UpdateReviewRequestBodyImagesInner
 */
export interface UpdateReviewRequestBodyImagesInner {
  /**
   *
   * @type {number}
   * @memberof UpdateReviewRequestBodyImagesInner
   */
  id: number;
  /**
   *
   * @type {string}
   * @memberof UpdateReviewRequestBodyImagesInner
   */
  source: string;
}
/**
 *
 * @export
 * @interface UpdateReviewRequestBodyImagesInnerAnyOf
 */
export interface UpdateReviewRequestBodyImagesInnerAnyOf {
  /**
   *
   * @type {number}
   * @memberof UpdateReviewRequestBodyImagesInnerAnyOf
   */
  id: number;
}
/**
 *
 * @export
 * @interface UpdateReviewRequestBodyImagesInnerAnyOf1
 */
export interface UpdateReviewRequestBodyImagesInnerAnyOf1 {
  /**
   *
   * @type {string}
   * @memberof UpdateReviewRequestBodyImagesInnerAnyOf1
   */
  source: string;
}
/**
 *
 * @export
 * @interface UpdateUserRequestBody
 */
export interface UpdateUserRequestBody {
  /**
   *
   * @type {string}
   * @memberof UpdateUserRequestBody
   */
  description?: string;
  /**
   *
   * @type {string}
   * @memberof UpdateUserRequestBody
   */
  nickname?: string;
  /**
   *
   * @type {string}
   * @memberof UpdateUserRequestBody
   */
  image?: string;
}
/**
 *
 * @export
 * @interface UpsertOauthAppRequestBody
 */
export interface UpsertOauthAppRequestBody {
  /**
   * 간편 로그인을 위한 인증 키 입니다. Google 의 경우에는 \"클라이언트 id\" 입니다. Kakao 의 경우에는 \"REST API 키\" 입니다. 실습을 위해 발급받은 키를 등록해주세요. 실제 서비스에서 사용 하는 키는 등록하시면 안됩니다.
   * @type {string}
   * @memberof UpsertOauthAppRequestBody
   */
  appKey: string;
  /**
   *
   * @type {OauthProvider}
   * @memberof UpsertOauthAppRequestBody
   */
  provider: OauthProvider;
}

/**
 *
 * @export
 * @interface User
 */
export interface User {
  /**
   *
   * @type {string}
   * @memberof User
   */
  updatedAt: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  createdAt: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  teamId: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  image: string | null;
  /**
   *
   * @type {string}
   * @memberof User
   */
  description: string;
  /**
   *
   * @type {string}
   * @memberof User
   */
  nickname: string;
  /**
   *
   * @type {number}
   * @memberof User
   */
  id: number;
}
/**
 *
 * @export
 * @interface UserDetail
 */
export interface UserDetail {
  /**
   *
   * @type {string}
   * @memberof UserDetail
   */
  updatedAt: string;
  /**
   *
   * @type {string}
   * @memberof UserDetail
   */
  createdAt: string;
  /**
   *
   * @type {string}
   * @memberof UserDetail
   */
  teamId: string;
  /**
   *
   * @type {string}
   * @memberof UserDetail
   */
  image: string | null;
  /**
   *
   * @type {string}
   * @memberof UserDetail
   */
  description: string;
  /**
   *
   * @type {string}
   * @memberof UserDetail
   */
  nickname: string;
  /**
   *
   * @type {number}
   * @memberof UserDetail
   */
  id: number;
  /**
   *
   * @type {UserDetailAllOfMostFavoriteCategory}
   * @memberof UserDetail
   */
  mostFavoriteCategory: UserDetailAllOfMostFavoriteCategory | null;
  /**
   *
   * @type {number}
   * @memberof UserDetail
   */
  averageRating: number;
  /**
   *
   * @type {number}
   * @memberof UserDetail
   */
  reviewCount: number;
  /**
   *
   * @type {number}
   * @memberof UserDetail
   */
  followeesCount: number;
  /**
   *
   * @type {number}
   * @memberof UserDetail
   */
  followersCount: number;
  /**
   *
   * @type {boolean}
   * @memberof UserDetail
   */
  isFollowing: boolean;
}
/**
 *
 * @export
 * @interface UserDetailAllOfMostFavoriteCategory
 */
export interface UserDetailAllOfMostFavoriteCategory {
  /**
   *
   * @type {string}
   * @memberof UserDetailAllOfMostFavoriteCategory
   */
  name: string;
  /**
   *
   * @type {number}
   * @memberof UserDetailAllOfMostFavoriteCategory
   */
  id: number;
}
/**
 *
 * @export
 * @interface UserRanking
 */
export interface UserRanking {
  /**
   *
   * @type {string}
   * @memberof UserRanking
   */
  updatedAt: string;
  /**
   *
   * @type {string}
   * @memberof UserRanking
   */
  createdAt: string;
  /**
   *
   * @type {string}
   * @memberof UserRanking
   */
  teamId: string;
  /**
   *
   * @type {string}
   * @memberof UserRanking
   */
  image: string | null;
  /**
   *
   * @type {string}
   * @memberof UserRanking
   */
  description: string;
  /**
   *
   * @type {string}
   * @memberof UserRanking
   */
  nickname: string;
  /**
   *
   * @type {number}
   * @memberof UserRanking
   */
  id: number;
  /**
   *
   * @type {number}
   * @memberof UserRanking
   */
  reviewCount: number;
  /**
   *
   * @type {number}
   * @memberof UserRanking
   */
  followersCount: number;
}

/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * 로그인
     * @param {string} teamId teamId에 대한 설명
     * @param {SignInRequestBody} signInRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    signIn: async (
      teamId: string,
      signInRequestBody: SignInRequestBody,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'teamId' is not null or undefined
      assertParamExists('signIn', 'teamId', teamId);
      // verify required parameter 'signInRequestBody' is not null or undefined
      assertParamExists('signIn', 'signInRequestBody', signInRequestBody);
      const localVarPath = `/{teamId}/auth/signIn`.replace(
        `{${'teamId'}}`,
        encodeURIComponent(String(teamId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        signInRequestBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 간편 로그인
     * @param {string} teamId
     * @param {OauthProvider} provider
     * @param {SignInWithOauthRequestBody} signInWithOauthRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    signInOauth: async (
      teamId: string,
      provider: OauthProvider,
      signInWithOauthRequestBody: SignInWithOauthRequestBody,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'teamId' is not null or undefined
      assertParamExists('signInOauth', 'teamId', teamId);
      // verify required parameter 'provider' is not null or undefined
      assertParamExists('signInOauth', 'provider', provider);
      // verify required parameter 'signInWithOauthRequestBody' is not null or undefined
      assertParamExists('signInOauth', 'signInWithOauthRequestBody', signInWithOauthRequestBody);
      const localVarPath = `/{teamId}/auth/signIn/{provider}`
        .replace(`{${'teamId'}}`, encodeURIComponent(String(teamId)))
        .replace(`{${'provider'}}`, encodeURIComponent(String(provider)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        signInWithOauthRequestBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 회원가입
     * @param {string} teamId
     * @param {SignUpRequestBody} signUpRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    signUp: async (
      teamId: string,
      signUpRequestBody: SignUpRequestBody,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'teamId' is not null or undefined
      assertParamExists('signUp', 'teamId', teamId);
      // verify required parameter 'signUpRequestBody' is not null or undefined
      assertParamExists('signUp', 'signUpRequestBody', signUpRequestBody);
      const localVarPath = `/{teamId}/auth/signUp`.replace(
        `{${'teamId'}}`,
        encodeURIComponent(String(teamId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        signUpRequestBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 간편 회원가입
     * @param {string} teamId
     * @param {OauthProvider} provider
     * @param {SignUpWithOauthRequestBody} signUpWithOauthRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    signUpOauth: async (
      teamId: string,
      provider: OauthProvider,
      signUpWithOauthRequestBody: SignUpWithOauthRequestBody,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'teamId' is not null or undefined
      assertParamExists('signUpOauth', 'teamId', teamId);
      // verify required parameter 'provider' is not null or undefined
      assertParamExists('signUpOauth', 'provider', provider);
      // verify required parameter 'signUpWithOauthRequestBody' is not null or undefined
      assertParamExists('signUpOauth', 'signUpWithOauthRequestBody', signUpWithOauthRequestBody);
      const localVarPath = `/{teamId}/auth/signUp/{provider}`
        .replace(`{${'teamId'}}`, encodeURIComponent(String(teamId)))
        .replace(`{${'provider'}}`, encodeURIComponent(String(provider)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        signUpWithOauthRequestBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration);
  return {
    /**
     * 로그인
     * @param {string} teamId teamId에 대한 설명
     * @param {SignInRequestBody} signInRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async signIn(
      teamId: string,
      signInRequestBody: SignInRequestBody,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SignInResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.signIn(
        teamId,
        signInRequestBody,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AuthApi.signIn']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * 간편 로그인
     * @param {string} teamId
     * @param {OauthProvider} provider
     * @param {SignInWithOauthRequestBody} signInWithOauthRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async signInOauth(
      teamId: string,
      provider: OauthProvider,
      signInWithOauthRequestBody: SignInWithOauthRequestBody,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SignInResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.signInOauth(
        teamId,
        provider,
        signInWithOauthRequestBody,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AuthApi.signInOauth']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * 회원가입
     * @param {string} teamId
     * @param {SignUpRequestBody} signUpRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async signUp(
      teamId: string,
      signUpRequestBody: SignUpRequestBody,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SignUpResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.signUp(
        teamId,
        signUpRequestBody,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AuthApi.signUp']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * 간편 회원가입
     * @param {string} teamId
     * @param {OauthProvider} provider
     * @param {SignUpWithOauthRequestBody} signUpWithOauthRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async signUpOauth(
      teamId: string,
      provider: OauthProvider,
      signUpWithOauthRequestBody: SignUpWithOauthRequestBody,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SignUpResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.signUpOauth(
        teamId,
        provider,
        signUpWithOauthRequestBody,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['AuthApi.signUpOauth']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = AuthApiFp(configuration);
  return {
    /**
     * 로그인
     * @param {string} teamId teamId에 대한 설명
     * @param {SignInRequestBody} signInRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    signIn(
      teamId: string,
      signInRequestBody: SignInRequestBody,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<SignInResponse> {
      return localVarFp
        .signIn(teamId, signInRequestBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * 간편 로그인
     * @param {string} teamId
     * @param {OauthProvider} provider
     * @param {SignInWithOauthRequestBody} signInWithOauthRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    signInOauth(
      teamId: string,
      provider: OauthProvider,
      signInWithOauthRequestBody: SignInWithOauthRequestBody,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<SignInResponse> {
      return localVarFp
        .signInOauth(teamId, provider, signInWithOauthRequestBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * 회원가입
     * @param {string} teamId
     * @param {SignUpRequestBody} signUpRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    signUp(
      teamId: string,
      signUpRequestBody: SignUpRequestBody,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<SignUpResponse> {
      return localVarFp
        .signUp(teamId, signUpRequestBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * 간편 회원가입
     * @param {string} teamId
     * @param {OauthProvider} provider
     * @param {SignUpWithOauthRequestBody} signUpWithOauthRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    signUpOauth(
      teamId: string,
      provider: OauthProvider,
      signUpWithOauthRequestBody: SignUpWithOauthRequestBody,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<SignUpResponse> {
      return localVarFp
        .signUpOauth(teamId, provider, signUpWithOauthRequestBody, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
  /**
   * 로그인
   * @param {string} teamId teamId에 대한 설명
   * @param {SignInRequestBody} signInRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public signIn(
    teamId: string,
    signInRequestBody: SignInRequestBody,
    options?: RawAxiosRequestConfig,
  ) {
    return AuthApiFp(this.configuration)
      .signIn(teamId, signInRequestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * 간편 로그인
   * @param {string} teamId
   * @param {OauthProvider} provider
   * @param {SignInWithOauthRequestBody} signInWithOauthRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public signInOauth(
    teamId: string,
    provider: OauthProvider,
    signInWithOauthRequestBody: SignInWithOauthRequestBody,
    options?: RawAxiosRequestConfig,
  ) {
    return AuthApiFp(this.configuration)
      .signInOauth(teamId, provider, signInWithOauthRequestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * 회원가입
   * @param {string} teamId
   * @param {SignUpRequestBody} signUpRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public signUp(
    teamId: string,
    signUpRequestBody: SignUpRequestBody,
    options?: RawAxiosRequestConfig,
  ) {
    return AuthApiFp(this.configuration)
      .signUp(teamId, signUpRequestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * 간편 회원가입
   * @param {string} teamId
   * @param {OauthProvider} provider
   * @param {SignUpWithOauthRequestBody} signUpWithOauthRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public signUpOauth(
    teamId: string,
    provider: OauthProvider,
    signUpWithOauthRequestBody: SignUpWithOauthRequestBody,
    options?: RawAxiosRequestConfig,
  ) {
    return AuthApiFp(this.configuration)
      .signUpOauth(teamId, provider, signUpWithOauthRequestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * CategoryApi - axios parameter creator
 * @export
 */
export const CategoryApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @param {string} teamId teamId에 대한 설명
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listAllCategory: async (
      teamId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'teamId' is not null or undefined
      assertParamExists('listAllCategory', 'teamId', teamId);
      const localVarPath = `/{teamId}/categories`.replace(
        `{${'teamId'}}`,
        encodeURIComponent(String(teamId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * CategoryApi - functional programming interface
 * @export
 */
export const CategoryApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = CategoryApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {string} teamId teamId에 대한 설명
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listAllCategory(
      teamId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Category>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listAllCategory(teamId, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['CategoryApi.listAllCategory']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * CategoryApi - factory interface
 * @export
 */
export const CategoryApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = CategoryApiFp(configuration);
  return {
    /**
     *
     * @param {string} teamId teamId에 대한 설명
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listAllCategory(
      teamId: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<Array<Category>> {
      return localVarFp
        .listAllCategory(teamId, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * CategoryApi - object-oriented interface
 * @export
 * @class CategoryApi
 * @extends {BaseAPI}
 */
export class CategoryApi extends BaseAPI {
  /**
   *
   * @param {string} teamId teamId에 대한 설명
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CategoryApi
   */
  public listAllCategory(teamId: string, options?: RawAxiosRequestConfig) {
    return CategoryApiFp(this.configuration)
      .listAllCategory(teamId, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * FollowApi - axios parameter creator
 * @export
 */
export const FollowApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * 유저 팔로우
     * @param {string} teamId
     * @param {FollowRequestBody} followRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    follow: async (
      teamId: string,
      followRequestBody: FollowRequestBody,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'teamId' is not null or undefined
      assertParamExists('follow', 'teamId', teamId);
      // verify required parameter 'followRequestBody' is not null or undefined
      assertParamExists('follow', 'followRequestBody', followRequestBody);
      const localVarPath = `/{teamId}/follow`.replace(
        `{${'teamId'}}`,
        encodeURIComponent(String(teamId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication jwt required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        followRequestBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 유저 언팔로우
     * @param {string} teamId
     * @param {FollowRequestBody} followRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unfollow: async (
      teamId: string,
      followRequestBody: FollowRequestBody,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'teamId' is not null or undefined
      assertParamExists('unfollow', 'teamId', teamId);
      // verify required parameter 'followRequestBody' is not null or undefined
      assertParamExists('unfollow', 'followRequestBody', followRequestBody);
      const localVarPath = `/{teamId}/follow`.replace(
        `{${'teamId'}}`,
        encodeURIComponent(String(teamId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication jwt required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        followRequestBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * FollowApi - functional programming interface
 * @export
 */
export const FollowApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = FollowApiAxiosParamCreator(configuration);
  return {
    /**
     * 유저 팔로우
     * @param {string} teamId
     * @param {FollowRequestBody} followRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async follow(
      teamId: string,
      followRequestBody: FollowRequestBody,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDetail>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.follow(
        teamId,
        followRequestBody,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['FollowApi.follow']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * 유저 언팔로우
     * @param {string} teamId
     * @param {FollowRequestBody} followRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async unfollow(
      teamId: string,
      followRequestBody: FollowRequestBody,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDetail>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.unfollow(
        teamId,
        followRequestBody,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['FollowApi.unfollow']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * FollowApi - factory interface
 * @export
 */
export const FollowApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = FollowApiFp(configuration);
  return {
    /**
     * 유저 팔로우
     * @param {string} teamId
     * @param {FollowRequestBody} followRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    follow(
      teamId: string,
      followRequestBody: FollowRequestBody,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<UserDetail> {
      return localVarFp
        .follow(teamId, followRequestBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * 유저 언팔로우
     * @param {string} teamId
     * @param {FollowRequestBody} followRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unfollow(
      teamId: string,
      followRequestBody: FollowRequestBody,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<UserDetail> {
      return localVarFp
        .unfollow(teamId, followRequestBody, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * FollowApi - object-oriented interface
 * @export
 * @class FollowApi
 * @extends {BaseAPI}
 */
export class FollowApi extends BaseAPI {
  /**
   * 유저 팔로우
   * @param {string} teamId
   * @param {FollowRequestBody} followRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FollowApi
   */
  public follow(
    teamId: string,
    followRequestBody: FollowRequestBody,
    options?: RawAxiosRequestConfig,
  ) {
    return FollowApiFp(this.configuration)
      .follow(teamId, followRequestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * 유저 언팔로우
   * @param {string} teamId
   * @param {FollowRequestBody} followRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FollowApi
   */
  public unfollow(
    teamId: string,
    followRequestBody: FollowRequestBody,
    options?: RawAxiosRequestConfig,
  ) {
    return FollowApiFp(this.configuration)
      .unfollow(teamId, followRequestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * ImageApi - axios parameter creator
 * @export
 */
export const ImageApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * 이미지 업로드, 프로젝트에 저장하는 이미지들은 이 엔드포인트를 통해 업로드한 후 URL을 획득하여 사용합니다.
     * @param {string} teamId
     * @param {File} image 이미지 파일, 최대 용량은 5MB입니다.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    imageUpload: async (
      teamId: string,
      image: File,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'teamId' is not null or undefined
      assertParamExists('imageUpload', 'teamId', teamId);
      // verify required parameter 'image' is not null or undefined
      assertParamExists('imageUpload', 'image', image);
      const localVarPath = `/{teamId}/images/upload`.replace(
        `{${'teamId'}}`,
        encodeURIComponent(String(teamId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;
      const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

      // authentication jwt required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (image !== undefined) {
        localVarFormParams.append('image', image as any);
      }

      localVarHeaderParameter['Content-Type'] = 'multipart/form-data';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = localVarFormParams;

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ImageApi - functional programming interface
 * @export
 */
export const ImageApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ImageApiAxiosParamCreator(configuration);
  return {
    /**
     * 이미지 업로드, 프로젝트에 저장하는 이미지들은 이 엔드포인트를 통해 업로드한 후 URL을 획득하여 사용합니다.
     * @param {string} teamId
     * @param {File} image 이미지 파일, 최대 용량은 5MB입니다.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async imageUpload(
      teamId: string,
      image: File,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageUpload200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.imageUpload(teamId, image, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ImageApi.imageUpload']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * ImageApi - factory interface
 * @export
 */
export const ImageApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = ImageApiFp(configuration);
  return {
    /**
     * 이미지 업로드, 프로젝트에 저장하는 이미지들은 이 엔드포인트를 통해 업로드한 후 URL을 획득하여 사용합니다.
     * @param {string} teamId
     * @param {File} image 이미지 파일, 최대 용량은 5MB입니다.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    imageUpload(
      teamId: string,
      image: File,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ImageUpload200Response> {
      return localVarFp
        .imageUpload(teamId, image, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * ImageApi - object-oriented interface
 * @export
 * @class ImageApi
 * @extends {BaseAPI}
 */
export class ImageApi extends BaseAPI {
  /**
   * 이미지 업로드, 프로젝트에 저장하는 이미지들은 이 엔드포인트를 통해 업로드한 후 URL을 획득하여 사용합니다.
   * @param {string} teamId
   * @param {File} image 이미지 파일, 최대 용량은 5MB입니다.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ImageApi
   */
  public imageUpload(teamId: string, image: File, options?: RawAxiosRequestConfig) {
    return ImageApiFp(this.configuration)
      .imageUpload(teamId, image, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * OauthApi - axios parameter creator
 * @export
 */
export const OauthApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * 간편 로그인 App 등록/수정<br/> Google, Kakao 간편 로그인을 위한 App 을 등록하거나 수정합니다.<br/> 이미 등록된 앱이 있을 경우 덮어씌워집니다.  요청 데이터 중 appKey 는 각 서비스에서 발급받은 인증 키 입니다.<br/> Google 의 경우에는 <b>\"클라이언트 id\"</b> 입니다.<br/> Kakao 의 경우에는 <b>\"REST API 키\"</b> 입니다.<br/> 실습을 위해 발급받은 키를 등록해주세요. 실제 서비스에서 사용 하는 키를 등록해서는 안됩니다.
     * @param {string} teamId
     * @param {UpsertOauthAppRequestBody} upsertOauthAppRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    upsertOauthApp: async (
      teamId: string,
      upsertOauthAppRequestBody: UpsertOauthAppRequestBody,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'teamId' is not null or undefined
      assertParamExists('upsertOauthApp', 'teamId', teamId);
      // verify required parameter 'upsertOauthAppRequestBody' is not null or undefined
      assertParamExists('upsertOauthApp', 'upsertOauthAppRequestBody', upsertOauthAppRequestBody);
      const localVarPath = `/{teamId}/oauthApps`.replace(
        `{${'teamId'}}`,
        encodeURIComponent(String(teamId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        upsertOauthAppRequestBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * OauthApi - functional programming interface
 * @export
 */
export const OauthApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = OauthApiAxiosParamCreator(configuration);
  return {
    /**
     * 간편 로그인 App 등록/수정<br/> Google, Kakao 간편 로그인을 위한 App 을 등록하거나 수정합니다.<br/> 이미 등록된 앱이 있을 경우 덮어씌워집니다.  요청 데이터 중 appKey 는 각 서비스에서 발급받은 인증 키 입니다.<br/> Google 의 경우에는 <b>\"클라이언트 id\"</b> 입니다.<br/> Kakao 의 경우에는 <b>\"REST API 키\"</b> 입니다.<br/> 실습을 위해 발급받은 키를 등록해주세요. 실제 서비스에서 사용 하는 키를 등록해서는 안됩니다.
     * @param {string} teamId
     * @param {UpsertOauthAppRequestBody} upsertOauthAppRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async upsertOauthApp(
      teamId: string,
      upsertOauthAppRequestBody: UpsertOauthAppRequestBody,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OauthApp>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.upsertOauthApp(
        teamId,
        upsertOauthAppRequestBody,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['OauthApi.upsertOauthApp']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * OauthApi - factory interface
 * @export
 */
export const OauthApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = OauthApiFp(configuration);
  return {
    /**
     * 간편 로그인 App 등록/수정<br/> Google, Kakao 간편 로그인을 위한 App 을 등록하거나 수정합니다.<br/> 이미 등록된 앱이 있을 경우 덮어씌워집니다.  요청 데이터 중 appKey 는 각 서비스에서 발급받은 인증 키 입니다.<br/> Google 의 경우에는 <b>\"클라이언트 id\"</b> 입니다.<br/> Kakao 의 경우에는 <b>\"REST API 키\"</b> 입니다.<br/> 실습을 위해 발급받은 키를 등록해주세요. 실제 서비스에서 사용 하는 키를 등록해서는 안됩니다.
     * @param {string} teamId
     * @param {UpsertOauthAppRequestBody} upsertOauthAppRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    upsertOauthApp(
      teamId: string,
      upsertOauthAppRequestBody: UpsertOauthAppRequestBody,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<OauthApp> {
      return localVarFp
        .upsertOauthApp(teamId, upsertOauthAppRequestBody, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * OauthApi - object-oriented interface
 * @export
 * @class OauthApi
 * @extends {BaseAPI}
 */
export class OauthApi extends BaseAPI {
  /**
   * 간편 로그인 App 등록/수정<br/> Google, Kakao 간편 로그인을 위한 App 을 등록하거나 수정합니다.<br/> 이미 등록된 앱이 있을 경우 덮어씌워집니다.  요청 데이터 중 appKey 는 각 서비스에서 발급받은 인증 키 입니다.<br/> Google 의 경우에는 <b>\"클라이언트 id\"</b> 입니다.<br/> Kakao 의 경우에는 <b>\"REST API 키\"</b> 입니다.<br/> 실습을 위해 발급받은 키를 등록해주세요. 실제 서비스에서 사용 하는 키를 등록해서는 안됩니다.
   * @param {string} teamId
   * @param {UpsertOauthAppRequestBody} upsertOauthAppRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OauthApi
   */
  public upsertOauthApp(
    teamId: string,
    upsertOauthAppRequestBody: UpsertOauthAppRequestBody,
    options?: RawAxiosRequestConfig,
  ) {
    return OauthApiFp(this.configuration)
      .upsertOauthApp(teamId, upsertOauthAppRequestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * ProductApi - axios parameter creator
 * @export
 */
export const ProductApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * 상품 생성
     * @param {string} teamId
     * @param {CreateProductRequestBody} createProductRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createProduct: async (
      teamId: string,
      createProductRequestBody: CreateProductRequestBody,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'teamId' is not null or undefined
      assertParamExists('createProduct', 'teamId', teamId);
      // verify required parameter 'createProductRequestBody' is not null or undefined
      assertParamExists('createProduct', 'createProductRequestBody', createProductRequestBody);
      const localVarPath = `/{teamId}/products`.replace(
        `{${'teamId'}}`,
        encodeURIComponent(String(teamId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication jwt required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createProductRequestBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 상품 삭제
     * @param {number} productId
     * @param {string} teamId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteProduct: async (
      productId: number,
      teamId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'productId' is not null or undefined
      assertParamExists('deleteProduct', 'productId', productId);
      // verify required parameter 'teamId' is not null or undefined
      assertParamExists('deleteProduct', 'teamId', teamId);
      const localVarPath = `/{teamId}/products/{productId}`
        .replace(`{${'productId'}}`, encodeURIComponent(String(productId)))
        .replace(`{${'teamId'}}`, encodeURIComponent(String(teamId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication jwt required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 상품 찜하기
     * @param {string} teamId
     * @param {number} productId 찜할 상품 ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    favorite: async (
      teamId: string,
      productId: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'teamId' is not null or undefined
      assertParamExists('favorite', 'teamId', teamId);
      // verify required parameter 'productId' is not null or undefined
      assertParamExists('favorite', 'productId', productId);
      const localVarPath = `/{teamId}/products/{productId}/favorite`
        .replace(`{${'teamId'}}`, encodeURIComponent(String(teamId)))
        .replace(`{${'productId'}}`, encodeURIComponent(String(productId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication jwt required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 상품 목록 조회
     * @param {string} teamId 팀 ID
     * @param {string} [keyword] 상품명 검색 키워드
     * @param {number} [category] 카테고리 ID
     * @param {ListProductOrderEnum} [order]
     * @param {number} [cursor] 다음 페이지를 위한 커서
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listProduct: async (
      teamId: string,
      keyword?: string,
      category?: number,
      order?: ListProductOrderEnum,
      cursor?: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'teamId' is not null or undefined
      assertParamExists('listProduct', 'teamId', teamId);
      const localVarPath = `/{teamId}/products`.replace(
        `{${'teamId'}}`,
        encodeURIComponent(String(teamId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (keyword !== undefined) {
        localVarQueryParameter['keyword'] = keyword;
      }

      if (category !== undefined) {
        localVarQueryParameter['category'] = category;
      }

      if (order !== undefined) {
        localVarQueryParameter['order'] = order;
      }

      if (cursor !== undefined) {
        localVarQueryParameter['cursor'] = cursor;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 상품 리뷰 목록 조회
     * @param {number} productId
     * @param {string} teamId
     * @param {ListReviewsOrderEnum} [order] 정렬 순서
     * @param {number} [cursor] 다음 페이지를 위한 커서
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listReviews: async (
      productId: number,
      teamId: string,
      order?: ListReviewsOrderEnum,
      cursor?: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'productId' is not null or undefined
      assertParamExists('listReviews', 'productId', productId);
      // verify required parameter 'teamId' is not null or undefined
      assertParamExists('listReviews', 'teamId', teamId);
      const localVarPath = `/{teamId}/products/{productId}/reviews`
        .replace(`{${'productId'}}`, encodeURIComponent(String(productId)))
        .replace(`{${'teamId'}}`, encodeURIComponent(String(teamId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication jwt required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (order !== undefined) {
        localVarQueryParameter['order'] = order;
      }

      if (cursor !== undefined) {
        localVarQueryParameter['cursor'] = cursor;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 상품 상세 조회
     * @param {number} productId
     * @param {string} teamId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveProduct: async (
      productId: number,
      teamId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'productId' is not null or undefined
      assertParamExists('retrieveProduct', 'productId', productId);
      // verify required parameter 'teamId' is not null or undefined
      assertParamExists('retrieveProduct', 'teamId', teamId);
      const localVarPath = `/{teamId}/products/{productId}`
        .replace(`{${'productId'}}`, encodeURIComponent(String(productId)))
        .replace(`{${'teamId'}}`, encodeURIComponent(String(teamId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication jwt required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 상품 찜하기 취소
     * @param {string} teamId
     * @param {number} productId 찜할 상품 ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unfavorite: async (
      teamId: string,
      productId: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'teamId' is not null or undefined
      assertParamExists('unfavorite', 'teamId', teamId);
      // verify required parameter 'productId' is not null or undefined
      assertParamExists('unfavorite', 'productId', productId);
      const localVarPath = `/{teamId}/products/{productId}/favorite`
        .replace(`{${'teamId'}}`, encodeURIComponent(String(teamId)))
        .replace(`{${'productId'}}`, encodeURIComponent(String(productId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication jwt required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 상품 수정
     * @param {number} productId
     * @param {string} teamId
     * @param {UpdateProductRequestBody} updateProductRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateProduct: async (
      productId: number,
      teamId: string,
      updateProductRequestBody: UpdateProductRequestBody,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'productId' is not null or undefined
      assertParamExists('updateProduct', 'productId', productId);
      // verify required parameter 'teamId' is not null or undefined
      assertParamExists('updateProduct', 'teamId', teamId);
      // verify required parameter 'updateProductRequestBody' is not null or undefined
      assertParamExists('updateProduct', 'updateProductRequestBody', updateProductRequestBody);
      const localVarPath = `/{teamId}/products/{productId}`
        .replace(`{${'productId'}}`, encodeURIComponent(String(productId)))
        .replace(`{${'teamId'}}`, encodeURIComponent(String(teamId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication jwt required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateProductRequestBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ProductApi - functional programming interface
 * @export
 */
export const ProductApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ProductApiAxiosParamCreator(configuration);
  return {
    /**
     * 상품 생성
     * @param {string} teamId
     * @param {CreateProductRequestBody} createProductRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createProduct(
      teamId: string,
      createProductRequestBody: CreateProductRequestBody,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductDetailType>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createProduct(
        teamId,
        createProductRequestBody,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ProductApi.createProduct']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * 상품 삭제
     * @param {number} productId
     * @param {string} teamId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteProduct(
      productId: number,
      teamId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteProduct200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProduct(
        productId,
        teamId,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ProductApi.deleteProduct']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * 상품 찜하기
     * @param {string} teamId
     * @param {number} productId 찜할 상품 ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async favorite(
      teamId: string,
      productId: number,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductDetailType>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.favorite(
        teamId,
        productId,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ProductApi.favorite']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * 상품 목록 조회
     * @param {string} teamId 팀 ID
     * @param {string} [keyword] 상품명 검색 키워드
     * @param {number} [category] 카테고리 ID
     * @param {ListProductOrderEnum} [order]
     * @param {number} [cursor] 다음 페이지를 위한 커서
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listProduct(
      teamId: string,
      keyword?: string,
      category?: number,
      order?: ListProductOrderEnum,
      cursor?: number,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<CursorBasedPaginationResponseProductListType>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listProduct(
        teamId,
        keyword,
        category,
        order,
        cursor,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ProductApi.listProduct']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * 상품 리뷰 목록 조회
     * @param {number} productId
     * @param {string} teamId
     * @param {ListReviewsOrderEnum} [order] 정렬 순서
     * @param {number} [cursor] 다음 페이지를 위한 커서
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listReviews(
      productId: number,
      teamId: string,
      order?: ListReviewsOrderEnum,
      cursor?: number,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<CursorBasedPaginationResponseReview>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listReviews(
        productId,
        teamId,
        order,
        cursor,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ProductApi.listReviews']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * 상품 상세 조회
     * @param {number} productId
     * @param {string} teamId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async retrieveProduct(
      productId: number,
      teamId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductDetailType>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveProduct(
        productId,
        teamId,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ProductApi.retrieveProduct']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * 상품 찜하기 취소
     * @param {string} teamId
     * @param {number} productId 찜할 상품 ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async unfavorite(
      teamId: string,
      productId: number,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductDetailType>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.unfavorite(
        teamId,
        productId,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ProductApi.unfavorite']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * 상품 수정
     * @param {number} productId
     * @param {string} teamId
     * @param {UpdateProductRequestBody} updateProductRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateProduct(
      productId: number,
      teamId: string,
      updateProductRequestBody: UpdateProductRequestBody,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductDetailType>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateProduct(
        productId,
        teamId,
        updateProductRequestBody,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ProductApi.updateProduct']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * ProductApi - factory interface
 * @export
 */
export const ProductApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = ProductApiFp(configuration);
  return {
    /**
     * 상품 생성
     * @param {string} teamId
     * @param {CreateProductRequestBody} createProductRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createProduct(
      teamId: string,
      createProductRequestBody: CreateProductRequestBody,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ProductDetailType> {
      return localVarFp
        .createProduct(teamId, createProductRequestBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * 상품 삭제
     * @param {number} productId
     * @param {string} teamId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteProduct(
      productId: number,
      teamId: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<DeleteProduct200Response> {
      return localVarFp
        .deleteProduct(productId, teamId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * 상품 찜하기
     * @param {string} teamId
     * @param {number} productId 찜할 상품 ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    favorite(
      teamId: string,
      productId: number,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ProductDetailType> {
      return localVarFp
        .favorite(teamId, productId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * 상품 목록 조회
     * @param {string} teamId 팀 ID
     * @param {string} [keyword] 상품명 검색 키워드
     * @param {number} [category] 카테고리 ID
     * @param {ListProductOrderEnum} [order]
     * @param {number} [cursor] 다음 페이지를 위한 커서
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listProduct(
      teamId: string,
      keyword?: string,
      category?: number,
      order?: ListProductOrderEnum,
      cursor?: number,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<CursorBasedPaginationResponseProductListType> {
      return localVarFp
        .listProduct(teamId, keyword, category, order, cursor, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * 상품 리뷰 목록 조회
     * @param {number} productId
     * @param {string} teamId
     * @param {ListReviewsOrderEnum} [order] 정렬 순서
     * @param {number} [cursor] 다음 페이지를 위한 커서
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listReviews(
      productId: number,
      teamId: string,
      order?: ListReviewsOrderEnum,
      cursor?: number,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<CursorBasedPaginationResponseReview> {
      return localVarFp
        .listReviews(productId, teamId, order, cursor, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * 상품 상세 조회
     * @param {number} productId
     * @param {string} teamId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveProduct(
      productId: number,
      teamId: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ProductDetailType> {
      return localVarFp
        .retrieveProduct(productId, teamId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * 상품 찜하기 취소
     * @param {string} teamId
     * @param {number} productId 찜할 상품 ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unfavorite(
      teamId: string,
      productId: number,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ProductDetailType> {
      return localVarFp
        .unfavorite(teamId, productId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * 상품 수정
     * @param {number} productId
     * @param {string} teamId
     * @param {UpdateProductRequestBody} updateProductRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateProduct(
      productId: number,
      teamId: string,
      updateProductRequestBody: UpdateProductRequestBody,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ProductDetailType> {
      return localVarFp
        .updateProduct(productId, teamId, updateProductRequestBody, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * ProductApi - object-oriented interface
 * @export
 * @class ProductApi
 * @extends {BaseAPI}
 */
export class ProductApi extends BaseAPI {
  /**
   * 상품 생성
   * @param {string} teamId
   * @param {CreateProductRequestBody} createProductRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProductApi
   */
  public createProduct(
    teamId: string,
    createProductRequestBody: CreateProductRequestBody,
    options?: RawAxiosRequestConfig,
  ) {
    return ProductApiFp(this.configuration)
      .createProduct(teamId, createProductRequestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * 상품 삭제
   * @param {number} productId
   * @param {string} teamId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProductApi
   */
  public deleteProduct(productId: number, teamId: string, options?: RawAxiosRequestConfig) {
    return ProductApiFp(this.configuration)
      .deleteProduct(productId, teamId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * 상품 찜하기
   * @param {string} teamId
   * @param {number} productId 찜할 상품 ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProductApi
   */
  public favorite(teamId: string, productId: number, options?: RawAxiosRequestConfig) {
    return ProductApiFp(this.configuration)
      .favorite(teamId, productId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * 상품 목록 조회
   * @param {string} teamId 팀 ID
   * @param {string} [keyword] 상품명 검색 키워드
   * @param {number} [category] 카테고리 ID
   * @param {ListProductOrderEnum} [order]
   * @param {number} [cursor] 다음 페이지를 위한 커서
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProductApi
   */
  public listProduct(
    teamId: string,
    keyword?: string,
    category?: number,
    order?: ListProductOrderEnum,
    cursor?: number,
    options?: RawAxiosRequestConfig,
  ) {
    return ProductApiFp(this.configuration)
      .listProduct(teamId, keyword, category, order, cursor, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * 상품 리뷰 목록 조회
   * @param {number} productId
   * @param {string} teamId
   * @param {ListReviewsOrderEnum} [order] 정렬 순서
   * @param {number} [cursor] 다음 페이지를 위한 커서
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProductApi
   */
  public listReviews(
    productId: number,
    teamId: string,
    order?: ListReviewsOrderEnum,
    cursor?: number,
    options?: RawAxiosRequestConfig,
  ) {
    return ProductApiFp(this.configuration)
      .listReviews(productId, teamId, order, cursor, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * 상품 상세 조회
   * @param {number} productId
   * @param {string} teamId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProductApi
   */
  public retrieveProduct(productId: number, teamId: string, options?: RawAxiosRequestConfig) {
    return ProductApiFp(this.configuration)
      .retrieveProduct(productId, teamId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * 상품 찜하기 취소
   * @param {string} teamId
   * @param {number} productId 찜할 상품 ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProductApi
   */
  public unfavorite(teamId: string, productId: number, options?: RawAxiosRequestConfig) {
    return ProductApiFp(this.configuration)
      .unfavorite(teamId, productId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * 상품 수정
   * @param {number} productId
   * @param {string} teamId
   * @param {UpdateProductRequestBody} updateProductRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProductApi
   */
  public updateProduct(
    productId: number,
    teamId: string,
    updateProductRequestBody: UpdateProductRequestBody,
    options?: RawAxiosRequestConfig,
  ) {
    return ProductApiFp(this.configuration)
      .updateProduct(productId, teamId, updateProductRequestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * @export
 */
export const ListProductOrderEnum = {
  Recent: 'recent',
  Rating: 'rating',
  ReviewCount: 'reviewCount',
} as const;
export type ListProductOrderEnum = (typeof ListProductOrderEnum)[keyof typeof ListProductOrderEnum];
/**
 * @export
 */
export const ListReviewsOrderEnum = {
  Recent: 'recent',
  RatingDesc: 'ratingDesc',
  RatingAsc: 'ratingAsc',
  LikeCount: 'likeCount',
} as const;
export type ListReviewsOrderEnum = (typeof ListReviewsOrderEnum)[keyof typeof ListReviewsOrderEnum];

/**
 * ReviewApi - axios parameter creator
 * @export
 */
export const ReviewApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * 리뷰 생성
     * @param {string} teamId
     * @param {CreateReviewRequestBody} createReviewRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createReview: async (
      teamId: string,
      createReviewRequestBody: CreateReviewRequestBody,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'teamId' is not null or undefined
      assertParamExists('createReview', 'teamId', teamId);
      // verify required parameter 'createReviewRequestBody' is not null or undefined
      assertParamExists('createReview', 'createReviewRequestBody', createReviewRequestBody);
      const localVarPath = `/{teamId}/reviews`.replace(
        `{${'teamId'}}`,
        encodeURIComponent(String(teamId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication jwt required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createReviewRequestBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 리뷰 삭제
     * @param {number} reviewId
     * @param {string} teamId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteReview: async (
      reviewId: number,
      teamId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'reviewId' is not null or undefined
      assertParamExists('deleteReview', 'reviewId', reviewId);
      // verify required parameter 'teamId' is not null or undefined
      assertParamExists('deleteReview', 'teamId', teamId);
      const localVarPath = `/{teamId}/reviews/{reviewId}`
        .replace(`{${'reviewId'}}`, encodeURIComponent(String(reviewId)))
        .replace(`{${'teamId'}}`, encodeURIComponent(String(teamId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication jwt required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 리뷰 좋아요
     * @param {string} teamId
     * @param {number} reviewId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    likeReview: async (
      teamId: string,
      reviewId: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'teamId' is not null or undefined
      assertParamExists('likeReview', 'teamId', teamId);
      // verify required parameter 'reviewId' is not null or undefined
      assertParamExists('likeReview', 'reviewId', reviewId);
      const localVarPath = `/{teamId}/reviews/{reviewId}/like`
        .replace(`{${'teamId'}}`, encodeURIComponent(String(teamId)))
        .replace(`{${'reviewId'}}`, encodeURIComponent(String(reviewId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication jwt required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 리뷰 좋아요 취소
     * @param {string} teamId
     * @param {number} reviewId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unlikeReview: async (
      teamId: string,
      reviewId: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'teamId' is not null or undefined
      assertParamExists('unlikeReview', 'teamId', teamId);
      // verify required parameter 'reviewId' is not null or undefined
      assertParamExists('unlikeReview', 'reviewId', reviewId);
      const localVarPath = `/{teamId}/reviews/{reviewId}/like`
        .replace(`{${'teamId'}}`, encodeURIComponent(String(teamId)))
        .replace(`{${'reviewId'}}`, encodeURIComponent(String(reviewId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication jwt required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 리뷰 수정 <br/> 이미지를 수정할 때, 기존 이미지를 유지하려면 id를, 새로운 이미지를 추가하려면 source를 넣어주세요. <br /> 요청에 포함되지 않는 기존 이미지는 삭제됩니다.
     * @param {number} reviewId
     * @param {string} teamId
     * @param {UpdateReviewRequestBody} updateReviewRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateReview: async (
      reviewId: number,
      teamId: string,
      updateReviewRequestBody: UpdateReviewRequestBody,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'reviewId' is not null or undefined
      assertParamExists('updateReview', 'reviewId', reviewId);
      // verify required parameter 'teamId' is not null or undefined
      assertParamExists('updateReview', 'teamId', teamId);
      // verify required parameter 'updateReviewRequestBody' is not null or undefined
      assertParamExists('updateReview', 'updateReviewRequestBody', updateReviewRequestBody);
      const localVarPath = `/{teamId}/reviews/{reviewId}`
        .replace(`{${'reviewId'}}`, encodeURIComponent(String(reviewId)))
        .replace(`{${'teamId'}}`, encodeURIComponent(String(teamId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication jwt required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateReviewRequestBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ReviewApi - functional programming interface
 * @export
 */
export const ReviewApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ReviewApiAxiosParamCreator(configuration);
  return {
    /**
     * 리뷰 생성
     * @param {string} teamId
     * @param {CreateReviewRequestBody} createReviewRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createReview(
      teamId: string,
      createReviewRequestBody: CreateReviewRequestBody,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Review>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createReview(
        teamId,
        createReviewRequestBody,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ReviewApi.createReview']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * 리뷰 삭제
     * @param {number} reviewId
     * @param {string} teamId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteReview(
      reviewId: number,
      teamId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteReview200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteReview(
        reviewId,
        teamId,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ReviewApi.deleteReview']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * 리뷰 좋아요
     * @param {string} teamId
     * @param {number} reviewId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async likeReview(
      teamId: string,
      reviewId: number,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Review>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.likeReview(
        teamId,
        reviewId,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ReviewApi.likeReview']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * 리뷰 좋아요 취소
     * @param {string} teamId
     * @param {number} reviewId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async unlikeReview(
      teamId: string,
      reviewId: number,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Review>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.unlikeReview(
        teamId,
        reviewId,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ReviewApi.unlikeReview']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * 리뷰 수정 <br/> 이미지를 수정할 때, 기존 이미지를 유지하려면 id를, 새로운 이미지를 추가하려면 source를 넣어주세요. <br /> 요청에 포함되지 않는 기존 이미지는 삭제됩니다.
     * @param {number} reviewId
     * @param {string} teamId
     * @param {UpdateReviewRequestBody} updateReviewRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateReview(
      reviewId: number,
      teamId: string,
      updateReviewRequestBody: UpdateReviewRequestBody,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Review>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateReview(
        reviewId,
        teamId,
        updateReviewRequestBody,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ReviewApi.updateReview']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * ReviewApi - factory interface
 * @export
 */
export const ReviewApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = ReviewApiFp(configuration);
  return {
    /**
     * 리뷰 생성
     * @param {string} teamId
     * @param {CreateReviewRequestBody} createReviewRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createReview(
      teamId: string,
      createReviewRequestBody: CreateReviewRequestBody,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<Review> {
      return localVarFp
        .createReview(teamId, createReviewRequestBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * 리뷰 삭제
     * @param {number} reviewId
     * @param {string} teamId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteReview(
      reviewId: number,
      teamId: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<DeleteReview200Response> {
      return localVarFp
        .deleteReview(reviewId, teamId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * 리뷰 좋아요
     * @param {string} teamId
     * @param {number} reviewId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    likeReview(
      teamId: string,
      reviewId: number,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<Review> {
      return localVarFp
        .likeReview(teamId, reviewId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * 리뷰 좋아요 취소
     * @param {string} teamId
     * @param {number} reviewId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unlikeReview(
      teamId: string,
      reviewId: number,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<Review> {
      return localVarFp
        .unlikeReview(teamId, reviewId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * 리뷰 수정 <br/> 이미지를 수정할 때, 기존 이미지를 유지하려면 id를, 새로운 이미지를 추가하려면 source를 넣어주세요. <br /> 요청에 포함되지 않는 기존 이미지는 삭제됩니다.
     * @param {number} reviewId
     * @param {string} teamId
     * @param {UpdateReviewRequestBody} updateReviewRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateReview(
      reviewId: number,
      teamId: string,
      updateReviewRequestBody: UpdateReviewRequestBody,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<Review> {
      return localVarFp
        .updateReview(reviewId, teamId, updateReviewRequestBody, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * ReviewApi - object-oriented interface
 * @export
 * @class ReviewApi
 * @extends {BaseAPI}
 */
export class ReviewApi extends BaseAPI {
  /**
   * 리뷰 생성
   * @param {string} teamId
   * @param {CreateReviewRequestBody} createReviewRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ReviewApi
   */
  public createReview(
    teamId: string,
    createReviewRequestBody: CreateReviewRequestBody,
    options?: RawAxiosRequestConfig,
  ) {
    return ReviewApiFp(this.configuration)
      .createReview(teamId, createReviewRequestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * 리뷰 삭제
   * @param {number} reviewId
   * @param {string} teamId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ReviewApi
   */
  public deleteReview(reviewId: number, teamId: string, options?: RawAxiosRequestConfig) {
    return ReviewApiFp(this.configuration)
      .deleteReview(reviewId, teamId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * 리뷰 좋아요
   * @param {string} teamId
   * @param {number} reviewId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ReviewApi
   */
  public likeReview(teamId: string, reviewId: number, options?: RawAxiosRequestConfig) {
    return ReviewApiFp(this.configuration)
      .likeReview(teamId, reviewId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * 리뷰 좋아요 취소
   * @param {string} teamId
   * @param {number} reviewId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ReviewApi
   */
  public unlikeReview(teamId: string, reviewId: number, options?: RawAxiosRequestConfig) {
    return ReviewApiFp(this.configuration)
      .unlikeReview(teamId, reviewId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * 리뷰 수정 <br/> 이미지를 수정할 때, 기존 이미지를 유지하려면 id를, 새로운 이미지를 추가하려면 source를 넣어주세요. <br /> 요청에 포함되지 않는 기존 이미지는 삭제됩니다.
   * @param {number} reviewId
   * @param {string} teamId
   * @param {UpdateReviewRequestBody} updateReviewRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ReviewApi
   */
  public updateReview(
    reviewId: number,
    teamId: string,
    updateReviewRequestBody: UpdateReviewRequestBody,
    options?: RawAxiosRequestConfig,
  ) {
    return ReviewApiFp(this.configuration)
      .updateReview(reviewId, teamId, updateReviewRequestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * 유저가 생성한 상품 조회
     * @param {string} teamId teamId에 대한 설명
     * @param {number} userId
     * @param {number} [cursor] 다음 페이지를 위한 커서
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listUserCreatedProducts: async (
      teamId: string,
      userId: number,
      cursor?: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'teamId' is not null or undefined
      assertParamExists('listUserCreatedProducts', 'teamId', teamId);
      // verify required parameter 'userId' is not null or undefined
      assertParamExists('listUserCreatedProducts', 'userId', userId);
      const localVarPath = `/{teamId}/users/{userId}/created-products`
        .replace(`{${'teamId'}}`, encodeURIComponent(String(teamId)))
        .replace(`{${'userId'}}`, encodeURIComponent(String(userId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (cursor !== undefined) {
        localVarQueryParameter['cursor'] = cursor;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 유저가 찜한 상품 조회
     * @param {string} teamId teamId에 대한 설명
     * @param {number} userId
     * @param {number} [cursor] 다음 페이지를 위한 커서
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listUserFavoriteProducts: async (
      teamId: string,
      userId: number,
      cursor?: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'teamId' is not null or undefined
      assertParamExists('listUserFavoriteProducts', 'teamId', teamId);
      // verify required parameter 'userId' is not null or undefined
      assertParamExists('listUserFavoriteProducts', 'userId', userId);
      const localVarPath = `/{teamId}/users/{userId}/favorite-products`
        .replace(`{${'teamId'}}`, encodeURIComponent(String(teamId)))
        .replace(`{${'userId'}}`, encodeURIComponent(String(userId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (cursor !== undefined) {
        localVarQueryParameter['cursor'] = cursor;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 유저가 팔로우한 유저 조회
     * @param {string} teamId teamId에 대한 설명
     * @param {number} userId
     * @param {number} [cursor]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listUserFollowees: async (
      teamId: string,
      userId: number,
      cursor?: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'teamId' is not null or undefined
      assertParamExists('listUserFollowees', 'teamId', teamId);
      // verify required parameter 'userId' is not null or undefined
      assertParamExists('listUserFollowees', 'userId', userId);
      const localVarPath = `/{teamId}/users/{userId}/followees`
        .replace(`{${'teamId'}}`, encodeURIComponent(String(teamId)))
        .replace(`{${'userId'}}`, encodeURIComponent(String(userId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (cursor !== undefined) {
        localVarQueryParameter['cursor'] = cursor;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 유저를 팔로우한 유저 조회
     * @param {string} teamId teamId에 대한 설명
     * @param {number} userId
     * @param {number} [cursor]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listUserFollowers: async (
      teamId: string,
      userId: number,
      cursor?: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'teamId' is not null or undefined
      assertParamExists('listUserFollowers', 'teamId', teamId);
      // verify required parameter 'userId' is not null or undefined
      assertParamExists('listUserFollowers', 'userId', userId);
      const localVarPath = `/{teamId}/users/{userId}/followers`
        .replace(`{${'teamId'}}`, encodeURIComponent(String(teamId)))
        .replace(`{${'userId'}}`, encodeURIComponent(String(userId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (cursor !== undefined) {
        localVarQueryParameter['cursor'] = cursor;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 유저가 리뷰한 상품 조회
     * @param {string} teamId teamId에 대한 설명
     * @param {number} userId
     * @param {number} [cursor] 다음 페이지를 위한 커서
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listUserReviewedProducts: async (
      teamId: string,
      userId: number,
      cursor?: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'teamId' is not null or undefined
      assertParamExists('listUserReviewedProducts', 'teamId', teamId);
      // verify required parameter 'userId' is not null or undefined
      assertParamExists('listUserReviewedProducts', 'userId', userId);
      const localVarPath = `/{teamId}/users/{userId}/reviewed-products`
        .replace(`{${'teamId'}}`, encodeURIComponent(String(teamId)))
        .replace(`{${'userId'}}`, encodeURIComponent(String(userId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (cursor !== undefined) {
        localVarQueryParameter['cursor'] = cursor;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 내 정보 조회
     * @param {string} teamId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    me: async (teamId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'teamId' is not null or undefined
      assertParamExists('me', 'teamId', teamId);
      const localVarPath = `/{teamId}/users/me`.replace(
        `{${'teamId'}}`,
        encodeURIComponent(String(teamId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication jwt required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 내 정보 수정
     * @param {string} teamId
     * @param {UpdateUserRequestBody} updateUserRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateMe: async (
      teamId: string,
      updateUserRequestBody: UpdateUserRequestBody,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'teamId' is not null or undefined
      assertParamExists('updateMe', 'teamId', teamId);
      // verify required parameter 'updateUserRequestBody' is not null or undefined
      assertParamExists('updateMe', 'updateUserRequestBody', updateUserRequestBody);
      const localVarPath = `/{teamId}/users/me`.replace(
        `{${'teamId'}}`,
        encodeURIComponent(String(teamId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication jwt required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateUserRequestBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 유저 정보 조회
     * @param {string} teamId
     * @param {number} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userDetail: async (
      teamId: string,
      userId: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'teamId' is not null or undefined
      assertParamExists('userDetail', 'teamId', teamId);
      // verify required parameter 'userId' is not null or undefined
      assertParamExists('userDetail', 'userId', userId);
      const localVarPath = `/{teamId}/users/{userId}`
        .replace(`{${'teamId'}}`, encodeURIComponent(String(teamId)))
        .replace(`{${'userId'}}`, encodeURIComponent(String(userId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication jwt required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 유저 랭킹 조회
     * @param {string} teamId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userRanking: async (
      teamId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'teamId' is not null or undefined
      assertParamExists('userRanking', 'teamId', teamId);
      const localVarPath = `/{teamId}/users/ranking`.replace(
        `{${'teamId'}}`,
        encodeURIComponent(String(teamId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration);
  return {
    /**
     * 유저가 생성한 상품 조회
     * @param {string} teamId teamId에 대한 설명
     * @param {number} userId
     * @param {number} [cursor] 다음 페이지를 위한 커서
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listUserCreatedProducts(
      teamId: string,
      userId: number,
      cursor?: number,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<CursorBasedPaginationResponseProductListType>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listUserCreatedProducts(
        teamId,
        userId,
        cursor,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['UserApi.listUserCreatedProducts']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * 유저가 찜한 상품 조회
     * @param {string} teamId teamId에 대한 설명
     * @param {number} userId
     * @param {number} [cursor] 다음 페이지를 위한 커서
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listUserFavoriteProducts(
      teamId: string,
      userId: number,
      cursor?: number,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<CursorBasedPaginationResponseProductListType>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listUserFavoriteProducts(
        teamId,
        userId,
        cursor,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['UserApi.listUserFavoriteProducts']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * 유저가 팔로우한 유저 조회
     * @param {string} teamId teamId에 대한 설명
     * @param {number} userId
     * @param {number} [cursor]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listUserFollowees(
      teamId: string,
      userId: number,
      cursor?: number,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<CursorBasedPaginationResponseIdNumberFolloweeUser>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listUserFollowees(
        teamId,
        userId,
        cursor,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['UserApi.listUserFollowees']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * 유저를 팔로우한 유저 조회
     * @param {string} teamId teamId에 대한 설명
     * @param {number} userId
     * @param {number} [cursor]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listUserFollowers(
      teamId: string,
      userId: number,
      cursor?: number,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<CursorBasedPaginationResponseIdNumberFollowerUser>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listUserFollowers(
        teamId,
        userId,
        cursor,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['UserApi.listUserFollowers']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * 유저가 리뷰한 상품 조회
     * @param {string} teamId teamId에 대한 설명
     * @param {number} userId
     * @param {number} [cursor] 다음 페이지를 위한 커서
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listUserReviewedProducts(
      teamId: string,
      userId: number,
      cursor?: number,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<CursorBasedPaginationResponseProductListType>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listUserReviewedProducts(
        teamId,
        userId,
        cursor,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['UserApi.listUserReviewedProducts']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * 내 정보 조회
     * @param {string} teamId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async me(
      teamId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDetail>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.me(teamId, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['UserApi.me']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * 내 정보 수정
     * @param {string} teamId
     * @param {UpdateUserRequestBody} updateUserRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateMe(
      teamId: string,
      updateUserRequestBody: UpdateUserRequestBody,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateMe200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateMe(
        teamId,
        updateUserRequestBody,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['UserApi.updateMe']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * 유저 정보 조회
     * @param {string} teamId
     * @param {number} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async userDetail(
      teamId: string,
      userId: number,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDetail>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.userDetail(teamId, userId, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['UserApi.userDetail']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * 유저 랭킹 조회
     * @param {string} teamId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async userRanking(
      teamId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserRanking>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.userRanking(teamId, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['UserApi.userRanking']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = UserApiFp(configuration);
  return {
    /**
     * 유저가 생성한 상품 조회
     * @param {string} teamId teamId에 대한 설명
     * @param {number} userId
     * @param {number} [cursor] 다음 페이지를 위한 커서
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listUserCreatedProducts(
      teamId: string,
      userId: number,
      cursor?: number,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<CursorBasedPaginationResponseProductListType> {
      return localVarFp
        .listUserCreatedProducts(teamId, userId, cursor, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * 유저가 찜한 상품 조회
     * @param {string} teamId teamId에 대한 설명
     * @param {number} userId
     * @param {number} [cursor] 다음 페이지를 위한 커서
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listUserFavoriteProducts(
      teamId: string,
      userId: number,
      cursor?: number,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<CursorBasedPaginationResponseProductListType> {
      return localVarFp
        .listUserFavoriteProducts(teamId, userId, cursor, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * 유저가 팔로우한 유저 조회
     * @param {string} teamId teamId에 대한 설명
     * @param {number} userId
     * @param {number} [cursor]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listUserFollowees(
      teamId: string,
      userId: number,
      cursor?: number,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<CursorBasedPaginationResponseIdNumberFolloweeUser> {
      return localVarFp
        .listUserFollowees(teamId, userId, cursor, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * 유저를 팔로우한 유저 조회
     * @param {string} teamId teamId에 대한 설명
     * @param {number} userId
     * @param {number} [cursor]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listUserFollowers(
      teamId: string,
      userId: number,
      cursor?: number,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<CursorBasedPaginationResponseIdNumberFollowerUser> {
      return localVarFp
        .listUserFollowers(teamId, userId, cursor, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * 유저가 리뷰한 상품 조회
     * @param {string} teamId teamId에 대한 설명
     * @param {number} userId
     * @param {number} [cursor] 다음 페이지를 위한 커서
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listUserReviewedProducts(
      teamId: string,
      userId: number,
      cursor?: number,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<CursorBasedPaginationResponseProductListType> {
      return localVarFp
        .listUserReviewedProducts(teamId, userId, cursor, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * 내 정보 조회
     * @param {string} teamId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    me(teamId: string, options?: RawAxiosRequestConfig): AxiosPromise<UserDetail> {
      return localVarFp.me(teamId, options).then((request) => request(axios, basePath));
    },
    /**
     * 내 정보 수정
     * @param {string} teamId
     * @param {UpdateUserRequestBody} updateUserRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateMe(
      teamId: string,
      updateUserRequestBody: UpdateUserRequestBody,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<UpdateMe200Response> {
      return localVarFp
        .updateMe(teamId, updateUserRequestBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * 유저 정보 조회
     * @param {string} teamId
     * @param {number} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userDetail(
      teamId: string,
      userId: number,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<UserDetail> {
      return localVarFp
        .userDetail(teamId, userId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * 유저 랭킹 조회
     * @param {string} teamId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userRanking(teamId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<UserRanking>> {
      return localVarFp.userRanking(teamId, options).then((request) => request(axios, basePath));
    },
  };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
  /**
   * 유저가 생성한 상품 조회
   * @param {string} teamId teamId에 대한 설명
   * @param {number} userId
   * @param {number} [cursor] 다음 페이지를 위한 커서
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public listUserCreatedProducts(
    teamId: string,
    userId: number,
    cursor?: number,
    options?: RawAxiosRequestConfig,
  ) {
    return UserApiFp(this.configuration)
      .listUserCreatedProducts(teamId, userId, cursor, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * 유저가 찜한 상품 조회
   * @param {string} teamId teamId에 대한 설명
   * @param {number} userId
   * @param {number} [cursor] 다음 페이지를 위한 커서
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public listUserFavoriteProducts(
    teamId: string,
    userId: number,
    cursor?: number,
    options?: RawAxiosRequestConfig,
  ) {
    return UserApiFp(this.configuration)
      .listUserFavoriteProducts(teamId, userId, cursor, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * 유저가 팔로우한 유저 조회
   * @param {string} teamId teamId에 대한 설명
   * @param {number} userId
   * @param {number} [cursor]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public listUserFollowees(
    teamId: string,
    userId: number,
    cursor?: number,
    options?: RawAxiosRequestConfig,
  ) {
    return UserApiFp(this.configuration)
      .listUserFollowees(teamId, userId, cursor, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * 유저를 팔로우한 유저 조회
   * @param {string} teamId teamId에 대한 설명
   * @param {number} userId
   * @param {number} [cursor]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public listUserFollowers(
    teamId: string,
    userId: number,
    cursor?: number,
    options?: RawAxiosRequestConfig,
  ) {
    return UserApiFp(this.configuration)
      .listUserFollowers(teamId, userId, cursor, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * 유저가 리뷰한 상품 조회
   * @param {string} teamId teamId에 대한 설명
   * @param {number} userId
   * @param {number} [cursor] 다음 페이지를 위한 커서
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public listUserReviewedProducts(
    teamId: string,
    userId: number,
    cursor?: number,
    options?: RawAxiosRequestConfig,
  ) {
    return UserApiFp(this.configuration)
      .listUserReviewedProducts(teamId, userId, cursor, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * 내 정보 조회
   * @param {string} teamId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public me(teamId: string, options?: RawAxiosRequestConfig) {
    return UserApiFp(this.configuration)
      .me(teamId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * 내 정보 수정
   * @param {string} teamId
   * @param {UpdateUserRequestBody} updateUserRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public updateMe(
    teamId: string,
    updateUserRequestBody: UpdateUserRequestBody,
    options?: RawAxiosRequestConfig,
  ) {
    return UserApiFp(this.configuration)
      .updateMe(teamId, updateUserRequestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * 유저 정보 조회
   * @param {string} teamId
   * @param {number} userId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public userDetail(teamId: string, userId: number, options?: RawAxiosRequestConfig) {
    return UserApiFp(this.configuration)
      .userDetail(teamId, userId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * 유저 랭킹 조회
   * @param {string} teamId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public userRanking(teamId: string, options?: RawAxiosRequestConfig) {
    return UserApiFp(this.configuration)
      .userRanking(teamId, options)
      .then((request) => request(this.axios, this.basePath));
  }
}
